use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Tell Cargo to rerun this script if fonts or layers directories change
    println!("cargo:rerun-if-changed=themes/fonts/");
    println!("cargo:rerun-if-changed=themes/layers/");

    let out_dir = env::var("OUT_DIR").unwrap();
    let fonts_dest = Path::new(&out_dir).join("embedded_fonts.rs");
    let layers_dest = Path::new(&out_dir).join("embedded_layers.rs");

    // ===== FONTS =====
    let fonts_dir = Path::new("themes/fonts");
    let mut font_entries = Vec::new();

    if fonts_dir.exists() {
        if let Ok(entries) = fs::read_dir(fonts_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("fd") {
                    if let Some(filename) = path.file_name().and_then(|s| s.to_str()) {
                        let font_name = filename.strip_suffix(".fd").unwrap();
                        let relative_path = path.to_str().unwrap();
                        font_entries.push((font_name.to_string(), relative_path.to_string()));
                    }
                }
            }
        }
    }

    // Sort for consistent ordering
    font_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the embedded fonts module
    let mut code = String::from("// Auto-generated file - do not edit manually\n");
    code.push_str("// Generated by build.rs from themes/fonts/*.fd\n\n");

    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use once_cell::sync::Lazy;\n\n");

    // Generate const for each font (using absolute path from CARGO_MANIFEST_DIR)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    for (name, path) in &font_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        let absolute_path = Path::new(&manifest_dir).join(path);
        code.push_str(&format!(
            "const {}: &str = include_str!(\"{}\");\n",
            const_name, absolute_path.display()
        ));
    }

    code.push_str("\n");

    // Generate the font map
    code.push_str("pub static EMBEDDED_FONTS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {\n");
    code.push_str("    let mut m = HashMap::new();\n");

    for (name, _) in &font_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        code.push_str(&format!("    m.insert(\"{}\", {});\n", name, const_name));
    }

    code.push_str("    m\n");
    code.push_str("});\n\n");

    // Generate list of available font names
    code.push_str("pub static FONT_NAMES: &[&str] = &[\n");
    for (name, _) in &font_entries {
        code.push_str(&format!("    \"{}\",\n", name));
    }
    code.push_str("];\n\n");

    // Generate default font constant
    code.push_str("pub const DEFAULT_FONT_NAME: &str = \"Verite_9x16\";\n");

    fs::write(fonts_dest, code).unwrap();

    // ===== LAYERS =====
    let layers_dir = Path::new("themes/layers");
    let mut layer_entries = Vec::new();

    if layers_dir.exists() {
        if let Ok(entries) = fs::read_dir(layers_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("gif") {
                    if let Some(filename) = path.file_name().and_then(|s| s.to_str()) {
                        let layer_name = filename.strip_suffix(".gif").unwrap();
                        let relative_path = path.to_str().unwrap();
                        layer_entries.push((layer_name.to_string(), relative_path.to_string()));
                    }
                }
            }
        }
    }

    // Sort for consistent ordering
    layer_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the embedded layers module
    let mut layers_code = String::from("// Auto-generated file - do not edit manually\n");
    layers_code.push_str("// Generated by build.rs from themes/layers/*.gif\n\n");
    layers_code.push_str("use std::collections::HashMap;\n");
    layers_code.push_str("use once_cell::sync::Lazy;\n\n");

    // Generate const for each layer (using absolute path and include_bytes!)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    for (name, path) in &layer_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        let absolute_path = Path::new(&manifest_dir).join(path);
        layers_code.push_str(&format!(
            "const {}: &[u8] = include_bytes!(\"{}\");\n",
            const_name, absolute_path.display()
        ));
    }

    layers_code.push_str("\n");

    // Generate the layer map
    layers_code.push_str("pub static EMBEDDED_LAYERS: Lazy<HashMap<&'static str, &'static [u8]>> = Lazy::new(|| {\n");
    layers_code.push_str("    let mut m = HashMap::new();\n");

    for (name, _) in &layer_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        layers_code.push_str(&format!("    m.insert(\"{}.gif\", {});\n", name, const_name));
    }

    layers_code.push_str("    m\n");
    layers_code.push_str("});\n\n");

    // Generate list of available layer names
    layers_code.push_str("pub static LAYER_NAMES: &[&str] = &[\n");
    for (name, _) in &layer_entries {
        layers_code.push_str(&format!("    \"{}.gif\",\n", name));
    }
    layers_code.push_str("];\n");

    fs::write(layers_dest, layers_code).unwrap();
}
