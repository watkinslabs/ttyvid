use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Tell Cargo to rerun this script if fonts directory changes
    println!("cargo:rerun-if-changed=themes/fonts/");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_fonts.rs");

    let fonts_dir = Path::new("themes/fonts");

    // Read all .fd font files
    let mut font_entries = Vec::new();

    if fonts_dir.exists() {
        if let Ok(entries) = fs::read_dir(fonts_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("fd") {
                    if let Some(filename) = path.file_name().and_then(|s| s.to_str()) {
                        let font_name = filename.strip_suffix(".fd").unwrap();
                        let relative_path = path.to_str().unwrap();
                        font_entries.push((font_name.to_string(), relative_path.to_string()));
                    }
                }
            }
        }
    }

    // Sort for consistent ordering
    font_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the embedded fonts module
    let mut code = String::from("// Auto-generated file - do not edit manually\n");
    code.push_str("// Generated by build.rs from themes/fonts/*.fd\n\n");

    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use once_cell::sync::Lazy;\n\n");

    // Generate const for each font (using absolute path from CARGO_MANIFEST_DIR)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    for (name, path) in &font_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        let absolute_path = Path::new(&manifest_dir).join(path);
        code.push_str(&format!(
            "const {}: &str = include_str!(\"{}\");\n",
            const_name, absolute_path.display()
        ));
    }

    code.push_str("\n");

    // Generate the font map
    code.push_str("pub static EMBEDDED_FONTS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {\n");
    code.push_str("    let mut m = HashMap::new();\n");

    for (name, _) in &font_entries {
        let const_name = name.to_uppercase().replace('-', "_").replace('.', "_");
        code.push_str(&format!("    m.insert(\"{}\", {});\n", name, const_name));
    }

    code.push_str("    m\n");
    code.push_str("});\n\n");

    // Generate list of available font names
    code.push_str("pub static FONT_NAMES: &[&str] = &[\n");
    for (name, _) in &font_entries {
        code.push_str(&format!("    \"{}\",\n", name));
    }
    code.push_str("];\n\n");

    // Generate default font constant
    code.push_str("pub const DEFAULT_FONT_NAME: &str = \"Verite_9x16\";\n");

    fs::write(dest_path, code).unwrap();
}
